/***
*/

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v0.utils.MathUtils;

import java.util.ArrayList;

class DBSCANKernel extends Kernel {

    private static int m_num_points_cell;

	// we do not set it to 21 because the input data will be really difficult to reshape
	// we set number of neighbour to 25, representing all the possible neighbour cells
	private static int m_num_neighbour;

	// number of cols for the input grid, currently must be set before the hardware compile
	private static int m_num_cols;
	private static DFEType m_dataType;

	// two parameters for the algorithm, use scalarInput
	// invalid data means that there are actually no data
	private static DFEVar m_sqr_eps;	
	private static DFEVar m_invalid_data;
	
	private static int bitWidthOfUINT32 = 32;
	
    protected DBSCANKernel(KernelParameters kp, DBSCANParameters parameters) {
        super(kp);
		
		m_num_points_cell	= parameters.getNumPointsCell();
		m_num_neighbour		= parameters.getNumNeighbour();
		m_num_cols			= parameters.getNumCols();
		m_dataType			= parameters.getInputType();

		DFEVar centerX = io.input("input", m_dataType);
		DFEVar centerY = stream.offset(centerX, 1);
		
		m_sqr_eps = io.scalarInput("sqrEps", m_dataType);
		m_invalid_data = io.scalarInput("invalidData", m_dataType);
		
		// cellControl, control when to swap to a new cell
		// when cellControl == 0, means a new cell comes in
		//		1. reset the matrix
		//		2. output = output_point (just copy the new result from parallelCalculate)
		// when cellControl == m_num_points_cell * 2 - 1, means a cell is processed
		//		1. send output to io.output
		int cellBitWidth = MathUtils.bitsToAddress(m_num_points_cell * 2);
		DFEVar cellControl = control.count.simpleCounter(cellBitWidth, m_num_points_cell * 2);

		// the first dimension refers to the cells, the second dimension refers to the points in that cell
		ArrayList<ArrayList<DFEVar> > matrix = new ArrayList<ArrayList<DFEVar> >();
		setMatrix(matrix, centerX, cellControl);
		
		// check = 1 means this input data is valid, and the current input is an X(not Y)
		// invalidAnswer = 0, means not connected if input is invalid
		DFEVar XYCounter = control.count.simpleCounter(1);
		DFEVar check = (centerX !== m_invalid_data) & (XYCounter === 0);
		DFEVar invalidAnswer = constant.var(dfeBool(), 0);
		
		// the relationship between different neighbour cells
		DFEVectorType<DFEVar> outputPointType = new DFEVectorType<DFEVar>(dfeBool(), m_num_neighbour);
		DFEVector<DFEVar> output_point = outputPointType.newInstance(this);
		for(int i=0; i<m_num_neighbour; i++)
			output_point[i] <== check ? parallelCalculateCell(matrix[i], centerX, centerY) : invalidAnswer;
				
		// for every input cell, we actually output a uint32_t, not 25 bits
		// because the output length should be divided by 16, or it will cause low efficiency
		DFEVectorType<DFEVar> outputType = new DFEVectorType<DFEVar>(dfeBool(), bitWidthOfUINT32);
		DFEVector<DFEVar> output = outputType.newInstance(this);
		
		// push pipeline factor = 0
		// remove all the buffers in this operation, can do accumulation on output in 1 clock cycle
		optimization.pushPipeliningFactor(0);
		for(int i=0; i<m_num_neighbour; i++){
			int where = bitWidthOfUINT32 - 1 - i;
			output[where] <== ( (cellControl === 0) ? output_point[i] : stream.offset(output[where], -1) | output_point[i]);
		}
		optimization.popPipeliningFactor();
	
		// these are useless output
		for(int i=0; i<bitWidthOfUINT32 - m_num_neighbour; i++)
			output[i] <== invalidAnswer;
	
		// io.output only have value when the points in a cell is all processed
        io.output("output", output, output.getType(), cellControl === (m_num_points_cell * 2 - 1));
    }
	
	private DFEVar parallelCalculateCell(ArrayList<DFEVar> cell, DFEVar centerX, DFEVar centerY){
		// return 1 means the current (centerX, centerY) should be connected to the neighbour cell
		// return 0 means not connected
		DFEVar[] temp = new DFEVar[cell.size() / 2];
		for(int i=0; i<cell.size() / 2; i++)
			temp[i] = judgeDistance(cell[2*i], cell[2*i+1], centerX, centerY);
		DFEVar ret_val = orTree(temp);
		return ret_val;
	}

	private void setMatrix(ArrayList<ArrayList<DFEVar> > matrix, DFEVar centerX, DFEVar cellControl){
		// in the for loop, set every cell in the matrix
		for(int i=0; i<m_num_neighbour; i++){
			ArrayList<DFEVar> cell = new ArrayList<DFEVar>();
			setCell(cell, i, centerX, cellControl);
			matrix.add(cell);
		}
	}
	
	private void setCell(ArrayList<DFEVar> cell, int i, DFEVar centerX, DFEVar cellControl){
		int cellOffset = 0;
		// offset of the different cells in matrix
		if(i >= 0 && i <= 4)
			cellOffset = -2 * (m_num_cols) + i - 2;
		else if(i >= 5 && i <= 9)
			cellOffset = -1 * (m_num_cols) + i - 7;
		else if(i >= 10 && i <= 14)
			cellOffset = i - 12;
		else if(i >= 15 && i <= 19)
			cellOffset = 1 * (m_num_cols) + i - 17;
		else if(i >= 20 && i <= 24)
			cellOffset = 2 * (m_num_cols) + i - 22;
		// here, *2 because the dimension of data is 2
		cellOffset = cellOffset * m_num_points_cell * 2;

		for(int j=0; j<m_num_points_cell; j++){
			// in the for loop, set every points in the cell
			DFEVar pointX = centerX.getType().newInstance(this);
			DFEVar pointY = centerX.getType().newInstance(this);
			
			// only change the matrix when cellControl === 0
			// which means that a new cell comes in
			optimization.pushPipeliningFactor(0);
			pointX <== (cellControl === 0) ? stream.offset(centerX, cellOffset + 2 * j) : stream.offset(pointX, -1);
			pointY <== (cellControl === 0) ? stream.offset(centerX, cellOffset + 2 * j + 1) : stream.offset(pointY, -1);
			optimization.popPipeliningFactor();

			cell.add(pointX);
			cell.add(pointY);
		}
	}

	private DFEVar judgeDistance(DFEVar x, DFEVar y, DFEVar centerX, DFEVar centerY) {
        // return if the distance between center and a certain point is less than sqrEps
        DFEVar diffx = centerX - x;
        DFEVar diffy = centerY - y;
        DFEVar sqrDist = diffx * diffx + diffy * diffy;
        return sqrDist < m_sqr_eps;
    }
	
	private DFEVar orTree(DFEVar[] input){
	    // the input variable should be dfeBool
		DFEVar[] or = new DFEVar[input.length / 2 + (input.length % 2)];
        for (int i=0; i<input.length / 2; i++) {
			or[i] = input[2 * i] | input[2 * i + 1];
		}
		if (input.length % 2 == 1) {
	        or[or.length - 1] = input[input.length - 1];
	    }
	    return or.length == 1 ? or[0] : orTree(or);
	}

}

