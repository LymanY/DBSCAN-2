/***
*/

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.*;
//import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

import java.util.ArrayList;

class DBSCANKernel extends Kernel {

    private static int m_num_points_cell;
	// we do not set it to 21 because the input data will be really difficult to reshape
	// we set number of neighbour to 24, ignore the right-bottom corner
	// 24bit / 8bit = 3, making it easy to represent which small clusters should be merged
	private static int m_num_neighbour;
	private static int m_num_rows;
	private static DFEType m_dataType;

	// two parameters for the algorithm, use scalarInput
	private static DFEVar m_sqr_eps;
	// minPts is not needed for the merging cluster algorithm
	//private static DFEVar m_minPts;

    protected DBSCANKernel(KernelParameters kp, DBSCANParameters parameters) {
        super(kp);
		
		m_num_points_cell	= parameters.getNumPointsCell();
		m_num_neighbour		= parameters.getNumNeighbour();
		m_num_rows			= parameters.getNumRows();
		m_dataType			= parameters.getInputType();

		DFEVar centerX = io.input("input", m_dataType);
		DFEVar centerY = stream.offset(centerX, 1);
		
		m_sqr_eps = io.scalarInput("sqrEps", m_dataType);
		//m_minPts = io.scalarInput("minPts", dfeInt(32));

		// the first dimension refers to the cells, the second dimension refers to the points in that cell
		ArrayList<ArrayList<DFEVar> > matrix = new ArrayList<ArrayList<DFEVar> >();
		setMatrix(matrix, centerX);
		
		// for every input data coordinate, we output 3byte, 
		// representing the merging relationship between different clusters
		DFEVectorType<DFEVar> outputType = new DFEVectorType<DFEVar>(dfeBool(), m_num_neighbour);
		DFEVector<DFEVar> output = outputType.newInstance(this);
		for(int i=0; i<m_num_neighbour; i++)
			output[i] <== parallelCalculateCell(matrix[i], centerX, centerY);
		
		DFEVar outputControl = control.count.simpleCounter(1);
        io.output("output", output, output.getType(), outputControl === 0);
    }
	
	private DFEVar parallelCalculateCell(ArrayList<DFEVar> cell, DFEVar centerX, DFEVar centerY){
		DFEVar[] temp = new DFEVar[cell.size() / 2];
		for(int i=0; i<cell.size() / 2; i++)
			temp[i] = judgeDistance(cell[2*i], cell[2*i+1], centerX, centerY);
		DFEVar ret_val = orTree(temp);
		return ret_val;
	}

	private void setMatrix(ArrayList<ArrayList<DFEVar> > matrix, DFEVar centerX){
		// in the for loop, set every cell in the matrix
		for(int i=0; i<m_num_neighbour; i++){
			ArrayList<DFEVar> cell = new ArrayList<DFEVar>();
			setCell(cell, i, centerX);
			matrix.add(cell);
		}
	}
	
	private void setCell(ArrayList<DFEVar> cell, int i, DFEVar centerX){
		int cellOffset = 0;
		if(i >= 0 && i <= 4)
			cellOffset = -2 * m_num_rows + i - 2;
		else if(i >= 5 && i <= 9)
			cellOffset = -1 * m_num_rows + i - 7;
		else if(i >= 10 && i <= 14)
			cellOffset = i - 12;
		else if(i >= 15 && i <= 19)
			cellOffset = 1 * m_num_rows + i - 17;
		else if(i >= 20 && i <= 23)
			cellOffset = 2 * m_num_rows + i - 22;
		// here, *2 because the dimension of data is 2
		cellOffset = cellOffset * m_num_points_cell * 2;

		for(int j=0; j<m_num_points_cell; j++){
			// in the for loop, set every points in the cell
			DFEVar pointX = stream.offset(centerX, cellOffset + 2 * j);
			DFEVar pointY = stream.offset(centerX, cellOffset + 2 * j + 1);
			cell.add(pointX);
			cell.add(pointY);
		}
	}

	private DFEVar judgeDistance(DFEVar x, DFEVar y, DFEVar centerX, DFEVar centerY) {
        // return if the distance between center and a certain point is less than sqrEps
        DFEVar diffx = centerX - x;
        DFEVar diffy = centerY - y;
        DFEVar sqrDist = diffx * diffx + diffy * diffy;
        return sqrDist <= m_sqr_eps;
    }
	
	/*
	private DFEVar adderTree(DFEVar[] input){
        // the input variable should be float or int
        DFEVar[] sums = new DFEVar[input.length / 2 + (input.length % 2)];
        for (int i = 0; i < input.length / 2; i++) {
            sums[i] = input[2 * i] + input[2 * i + 1];
        }
        if (input.length % 2 == 1) {
            sums[sums.length - 1] = input[input.length - 1];
        }
        return sums.length == 1 ? sums[0] : adderTree(sums);
    }
	*/

	private DFEVar orTree(DFEVar[] input){
	    // the input variable should be dfeBool
		DFEVar[] or = new DFEVar[input.length / 2 + (input.length % 2)];
        for (int i=0; i<input.length / 2; i++) {
			or[i] = input[2 * i] | input[2 * i + 1];
		}
		if (input.length % 2 == 1) {
	        or[or.length - 1] = input[input.length - 1];
	    }
	    return or.length == 1 ? or[0] : orTree(or);
	}
	
	/*
	private DFEVar minTree(DFEVar[] input){
		// the input variable should be float or int
		DFEVar[] minimum = new DFEVar[input.length / 2 + (input.length % 2)];
		for (int i=0; i<input.length / 2; i++) {
			minimum[i] = KernelMath.min(input[2 * i], input[2 * i + 1]);
		}
		if (input.length % 2 == 1) {
			minimum[minimum.length - 1] = input[input.length - 1];
		}
		return minimum.length == 1 ? minimum[0] : minTree(minimum);
	}
	
	private DFEVar safeOffset(DFEVar input, DFEVar cycle, int offset) {
		// add pipelineFactor to remove the 1 cycle postpone by the buffer
		optimization.pushPipeliningFactor(0);
		DFEVar ret_val = cycle < -offset ? 0 : stream.offset(input, offset);
		optimization.popPipeliningFactor();
		return ret_val;											
	}
	*/

}

