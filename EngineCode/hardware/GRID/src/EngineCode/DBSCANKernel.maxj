/***
*/

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v0.utils.MathUtils;

import java.util.ArrayList;

class DBSCANKernel extends Kernel {

    private static int m_num_points_cell;

	// we do not set it to 21 because the input data will be really difficult to reshape
	// we set number of neighbour to 25, representing all the possible neighbour cells
	private static int m_num_neighbour;

	// number of cols for the input grid, currently must be set before the hardware compile
	private static int m_num_cols;
	private static DFEType m_dataType;

	// two parameters for the algorithm, use scalarInput
	// invalid data means that there are actually no data
	private static DFEVar m_sqr_eps;	
	private static DFEVar m_invalid_data;
	
	private static int bitWidthOfUINT32 = 32;
	
    protected DBSCANKernel(KernelParameters kp, DBSCANParameters parameters) {
        super(kp);
		
		m_num_points_cell	= parameters.getNumPointsCell();
		m_num_neighbour		= parameters.getNumNeighbour();
		m_num_cols			= parameters.getNumCols();
		m_dataType			= parameters.getInputType();
		
		DFEVectorType<DFEVar> inputType = new DFEVectorType<DFEVar>(m_dataType, 2);
		DFEVector<DFEVar> centerXY = io.input("input", inputType);

		m_sqr_eps = io.scalarInput("sqrEps", m_dataType);
		m_invalid_data = io.scalarInput("invalidData", m_dataType);
		
		// cellControl, control when to swap to a new cell
		// when cellControl == 0, means a new cell comes in
		//		1. reset the matrix
		//		2. output = output_point (just copy the new result from parallelCalculate)
		// when cellControl == m_num_points_cell * 2 - 1, means a cell is processed
		//		1. send output to io.output
		int cellBitWidth = MathUtils.bitsToAddress(m_num_points_cell);
		DFEVar cellControl = control.count.simpleCounter(cellBitWidth, m_num_points_cell);

		// the first dimension refers to the cells, the second dimension refers to the points in that cell
		ArrayList<ArrayList< DFEVector<DFEVar> > > matrix = new ArrayList<ArrayList< DFEVector<DFEVar> > >();
		setMatrix(matrix, centerXY, cellControl);
		
		// check = 1 means this input data is valid, and the current input is an X(not Y)
		// invalidAnswer = 0, means not connected if input is invalid
		DFEVar check = (centerXY[0] !== m_invalid_data);
		DFEVar invalidAnswer = constant.var(dfeBool(), 0);
		
		// the relationship between different neighbour cells
		DFEVectorType<DFEVar> outputPointType = new DFEVectorType<DFEVar>(dfeBool(), m_num_neighbour);
		DFEVector<DFEVar> output_point = outputPointType.newInstance(this);
		
		optimization.pushDSPFactor(1);
		parallelComputeMatrix(output_point, matrix, centerXY, check, invalidAnswer);
		optimization.popDSPFactor();

		// for every input cell, we actually output a uint32_t, not 25 bits
		// because the output length should be divided by 16, or it will cause low efficiency
		DFEVectorType<DFEVar> outputType = new DFEVectorType<DFEVar>(dfeBool(), bitWidthOfUINT32);
		DFEVector<DFEVar> output = outputType.newInstance(this);
		
		// push pipeline factor = 0
		// remove all the buffers in this operation, can do accumulation on output in 1 clock cycle
		optimization.pushPipeliningFactor(0);
		for(int i=0; i<m_num_neighbour; i++){
			int where = bitWidthOfUINT32 - 1 - i;
			output[where] <== ( (cellControl === 0) ? output_point[i] : stream.offset(output[where], -1) | output_point[i]);
		}
		optimization.popPipeliningFactor();
	
		// these are useless output
		for(int i=0; i<bitWidthOfUINT32 - m_num_neighbour; i++)
			output[i] <== invalidAnswer;
	
		// io.output only have value when the points in a cell is all processed
        io.output("output", output, output.getType(), cellControl === (m_num_points_cell - 1));
    }
	
	private void parallelComputeMatrix(DFEVector<DFEVar> output_point, ArrayList<ArrayList<DFEVector<DFEVar> > > matrix, DFEVector<DFEVar> centerXY, DFEVar check, DFEVar invalidAnswer){
		for(int i=0; i<m_num_neighbour; i++){
			if(i == 0 || i == 4 || i == 20 || i == 24)
				output_point[i] <== invalidAnswer;
			else
				output_point[i] <== check ? parallelComputeCell(matrix[i], centerXY) : invalidAnswer;
		}
	}

	private DFEVar parallelComputeCell(ArrayList<DFEVector<DFEVar> > cell, DFEVector<DFEVar> centerXY){
		// return 1 means the current (centerX, centerY) should be connected to the neighbour cell
		// return 0 means not connected
		DFEVar[] temp = new DFEVar[cell.size()];
		for(int i=0; i<cell.size(); i++)
			temp[i] = judgeDistance(cell[i], centerXY);
		DFEVar ret_val = orTree(temp);
		return ret_val;
	}

	private void setMatrix(ArrayList<ArrayList<DFEVector<DFEVar> > > matrix, DFEVector<DFEVar> centerXY, DFEVar cellControl){
		// in the for loop, set every cell in the matrix
		for(int i=0; i<m_num_neighbour; i++){
			ArrayList<DFEVector<DFEVar> > cell = new ArrayList<DFEVector<DFEVar> >();
			setCell(cell, i, centerXY, cellControl);
			matrix.add(cell);
		}
	}
	
	private void setCell(ArrayList<DFEVector<DFEVar> > cell, int i, DFEVector<DFEVar> centerXY, DFEVar cellControl){
		int cellOffset = 0;
		// offset of the different cells in matrix
		if(i >= 1 && i <= 3)
			cellOffset = -2 * (m_num_cols) + i - 2;
		else if(i >= 5 && i <= 9)
			cellOffset = -1 * (m_num_cols) + i - 7;
		else if(i >= 10 && i <= 14)
			cellOffset = i - 12;
		else if(i >= 15 && i <= 19)
			cellOffset = 1 * (m_num_cols) + i - 17;
		else if(i >= 21 && i <= 23)
			cellOffset = 2 * (m_num_cols) + i - 22;
		else{
			// we do not add points when offset=0,4,20,24
			// because it is not possible to make a distance less than eps
			return;
		}
		cellOffset = cellOffset * m_num_points_cell * 2;

		for(int j=0; j<m_num_points_cell; j++){
			// in the for loop, set every points in the cell
			DFEVector<DFEVar> pointXY = centerXY.getType().newInstance(this);
			
			// only change the matrix when cellControl === 0
			// which means that a new cell comes in
			optimization.pushPipeliningFactor(0);
			pointXY <== (cellControl === 0) ? stream.offsetStriped(centerXY, cellOffset + j * 2) : stream.offsetStriped(pointXY, -2);
			optimization.popPipeliningFactor();

			cell.add(pointXY);
		}
	}

	private DFEVar judgeDistance(DFEVector<DFEVar> pointXY, DFEVector<DFEVar> centerXY) {
        // return if the distance between center and a certain point is less than sqrEps
		DFEVar diffx = centerXY[0] - pointXY[0];
        DFEVar diffy = centerXY[1] - pointXY[1];
        DFEVar sqrDist = diffx * diffx + diffy * diffy;
        return sqrDist < m_sqr_eps;
    }
	
	private DFEVar orTree(DFEVar[] input){
	    // the input variable should be dfeBool
		DFEVar[] or = new DFEVar[input.length / 2 + (input.length % 2)];
        for (int i=0; i<input.length / 2; i++) {
			or[i] = input[2 * i] | input[2 * i + 1];
		}
		if (input.length % 2 == 1) {
	        or[or.length - 1] = input[input.length - 1];
	    }
	    return or.length == 1 ? or[0] : orTree(or);
	}

}

