/***
*/

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

import java.util.ArrayList;

class LSHKernel extends Kernel {
	
	// input data type
	private static DFEType m_inputType;

	// output data type for one point in one dim
	// the index range in each dimension is [-32768, 32767], should be enough for most cases
	private static final DFEType m_outType = dfeInt(16);

	// dimension of the input data
	private static int m_din_add;
	// maxeler can only input by even number
	private static int m_din = 7;

	// dimension of the output data, the dimension of LSH function
	// we can project the data from m_din space to m_dout space
	private static int m_dout;

	// for each LSH function, we construct m_redundent grids using different zero point
	private static int m_redundant;

    protected LSHKernel(KernelParameters kp, LSHParameters parameters) {
        super(kp);
		
		m_inputType = parameters.getInputType();
		m_din_add = parameters.getDIn();
		m_dout = parameters.getDOut();
		m_redundant = parameters.getRedundant();

		DFEVectorType<DFEVar> inputType = new DFEVectorType<DFEVar>(m_inputType, m_din_add);
		DFEVector<DFEVar> input = io.input("input", inputType);
		
		// the first dimension means a hash function
		// the second dimension means the parameters in a function
		ArrayList<ArrayList<DFEVar> > hashFunction = new ArrayList<ArrayList<DFEVar>>();
		setHashFunction(hashFunction);
	
		// step1 : do projection
		ArrayList<ArrayList<DFEVar> > multiply = doProjection(input, hashFunction);

		// step2 : add each dimension
		ArrayList<DFEVar> hashCoordinate = addProjection(multiply);
		
		// the first dimension means a dimension
		// the second dimension means a new center point
		ArrayList<ArrayList<DFEVar> > center = new ArrayList<ArrayList<DFEVar> >();
		setCenterPoint(center);
		
		// step3 : do the minus
		// the first dimension is m_dout dimension
		// the second dimension is the redundant
		ArrayList<ArrayList<DFEVar> > minus = doMinus(hashCoordinate, center);
		
		// the cell width is set from the scalarInput
		DFEVar cellWidth = io.scalarInput("cellWidth", m_inputType);

		// step4 : do the divide, also cast from float to int16
		ArrayList<ArrayList<DFEVar> > result = doDivideAndCast(minus, cellWidth);
		
		// for every input point(m_din dimensions) and every redundant, we output 2 int64_t to represent the HashCode
		// actually it is represented in 8 int16_t for convenience in the hardware
		// in CPU, the HashType will be defined as std::pair<int64_t, int64_t>
		DFEVectorType<DFEVar> outputType = new DFEVectorType<DFEVar>(m_outType, m_dout);

		// step5 : set the output for every redundant grid
		// the moveBitAndAdd function is not needed any more, because the output is already int16_t
		String out = "output";
		for(int i=0; i<m_redundant; i++){
			DFEVector<DFEVar> output = outputType.newInstance(this);
			for(int j=0; j<m_dout; j++){
				// must use TRUNCATE method to assign points to the correct cell
				// still have problem when the number is XXXX.0
				DFEVar upzero = result[j][i] >= constant.var(m_inputType, 0.0);
				DFEVar offset = upzero ? (result[j][i] - constant.var(m_inputType, 0.5)) : (result[j][i] + constant.var(m_inputType, 0.5));
				output[j] <== offset.cast(m_outType);
			}

			String outputName = out + Integer.toString(i);
		    io.output(outputName, output, output.getType());
		}
    } 
	
	private void setHashFunction(ArrayList<ArrayList<DFEVar> > hashFunction){
		for(int i=0; i<m_dout; i++){
			ArrayList<DFEVar> oneFunc = new ArrayList<DFEVar>();
			// use scalar input to get all the parameters
			for(int j=0; j<m_din; j++){
				String name = String.format("hashFunction%04d", i*m_din+j);
				DFEVar temp = io.scalarInput(name, m_inputType);
				oneFunc.add(temp);
			}
			hashFunction.add(oneFunc);
		}
	}

	private void setCenterPoint(ArrayList<ArrayList<DFEVar> > center){
		for(int i=0; i<m_dout; i++){
			ArrayList<DFEVar> oneDim = new ArrayList<DFEVar>();
			// use scalar input to get all the parameters
			for(int j=0; j<m_redundant; j++){
				String name = String.format("centerPoint%04d", j*m_dout+i);
				DFEVar temp = io.scalarInput(name, m_inputType);
				oneDim.add(temp);
			}
			center.add(oneDim);
		}
	}

	/*	
	private void setHashFunction(ArrayList<ArrayList<DFEVar> > hashFunction){
		int numBits = MathUtils.bitsToAddress(m_din);
		for(int i=0; i<m_dout; i++){
			ArrayList<DFEVar> oneFunc = new ArrayList<DFEVar>();
			Memory<DFEVar> mappedRom = mem.alloc(m_inputType, m_din);
			mappedRom.mapToCPU(String.format("hashFunction%04d", i));
			// map this memory to CPU
			for(int j=0; j<m_din; j++){
				oneFunc.add(mappedRom.read(constant.var(dfeUInt(numBits), j)));
			}
			hashFunction.add(oneFunc);
		}
	}
	
	private void setCenterPoint(ArrayList<ArrayList<DFEVar> > center){
		int numBits = MathUtils.bitsToAddress(m_redundant);
		for(int i=0; i<m_dout; i++){
			ArrayList<DFEVar> oneDim = new ArrayList<DFEVar>();
			Memory<DFEVar> mappedRom = mem.alloc(m_inputType, m_redundant);
			mappedRom.mapToCPU(String.format("centerPoint%04d", i));
			// map this memory to CPU
			for(int j=0; j<m_redundant; j++){
				oneDim.add(mappedRom.read(constant.var(dfeUInt(numBits), j)));
			}
			center.add(oneDim);
		}
	}
	*/

	private ArrayList<ArrayList<DFEVar> > doProjection(DFEVector<DFEVar> input, ArrayList<ArrayList<DFEVar> > hashFunction){
		ArrayList<ArrayList<DFEVar> > multiply = new ArrayList<ArrayList<DFEVar> >();
		for(int i=0; i<m_dout; i++){
			// oneDim means the multiply result of one dimension
			ArrayList<DFEVar> oneDim = new ArrayList<DFEVar>();
			for(int j=0; j<m_din; j++){
				DFEVar ans = input[j] * hashFunction[i][j];
				oneDim.add(ans);
			}
			multiply.add(oneDim);
		}
		return multiply;
	}
	
	private ArrayList<DFEVar> addProjection(ArrayList<ArrayList<DFEVar> > multiply){
		ArrayList<DFEVar> hashCoordinate = new ArrayList<DFEVar>();
		for(int i=0; i<m_dout; i++){
			DFEVar sum = adderTree(multiply[i]);
			hashCoordinate.add(sum);
		}
		return hashCoordinate;
	}
	
	private ArrayList<ArrayList<DFEVar> > doMinus(ArrayList<DFEVar> hashCoordinate, ArrayList<ArrayList<DFEVar> > center){
		ArrayList<ArrayList<DFEVar> > minus = new ArrayList<ArrayList<DFEVar> >();
		for(int i=0; i<m_dout; i++){
			ArrayList<DFEVar> oneDim = new ArrayList<DFEVar>();
			for(int j=0; j<m_redundant; j++){
				DFEVar m = hashCoordinate[i] - center[i][j];
				oneDim.add(m);
			}
			minus.add(oneDim);
		}
		return minus;
	}
	
	private ArrayList<ArrayList<DFEVar> > doDivideAndCast(ArrayList<ArrayList<DFEVar> > minus, DFEVar cellWidth){
		ArrayList<ArrayList<DFEVar> > result = new ArrayList<ArrayList<DFEVar> >();
		for(int i=0; i<m_dout; i++){
			ArrayList<DFEVar> oneDim = new ArrayList<DFEVar>();
			for(int j=0; j<m_redundant; j++)
				oneDim.add( minus[i][j] / cellWidth);
			result.add(oneDim);
		}
		return result;
	}
	
	private DFEVar adderTree(ArrayList<DFEVar> cell){
		ArrayList<DFEVar> sum = new ArrayList<DFEVar>();
		for(int i=0; i<cell.size() / 2; i++){
			sum.add( cell[2 * i] + cell[2 * i + 1] );
		}
		if(cell.size() % 2 == 1){
			sum.add( cell[cell.size() - 1] );
		}
		return sum.size() == 1 ? sum[0] : adderTree(sum);
	}

}

