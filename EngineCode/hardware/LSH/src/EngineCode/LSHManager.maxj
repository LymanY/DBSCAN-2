/***
    The manager for this design just streams data from CPU to DFE and back via PCI-E.
*/
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;

public class LSHManager extends CustomManager{

    private static final String s_kernelName  = "LSHKernel";

    LSHManager(LSHParameters params) {
        super(params);

        KernelBlock k =
	    addKernel(new LSHKernel(makeKernelParameters(s_kernelName), params));
		
		addConstant(params);

		// this algorithm has one input and several output
        k.getInput("input") <== addStreamFromCPU("input_cpu");

		int redundant = params.getRedundant();
		String toCPUPrefix = "output_cpu";
		String fromDFEPrefix = "output";
		for(int i=0; i<redundant; i++){
			String toCPU = toCPUPrefix + Integer.toString(i);
			String fromDFE = fromDFEPrefix + Integer.toString(i);
			addStreamToCPU(toCPU) <== k.getOutput(fromDFE);
		}

		// create SLiC interface here because we need the parameters 
		createSLiCinterface(interfaceDefault(params));
    }
	
	private void addConstant(LSHParameters param){
		addMaxFileConstant("din",		param.getDIn());
		addMaxFileConstant("dout",		param.getDOut());
		addMaxFileConstant("redundant",	param.getRedundant());
	}

    private static EngineInterface interfaceDefault(LSHParameters param) {
		int din = param.getDIn();
		int dout = param.getDOut();
		int redundant = param.getRedundant();

        EngineInterface engine_interface = new EngineInterface();
        
		// the parameter N is the number of input points
        InterfaceParam N = engine_interface.addParam("N", CPUTypes.INT);
        engine_interface.setTicks(s_kernelName, N);
		InterfaceParam cellWidth = engine_interface.addParam("cellWidth", CPUTypes.FLOAT);
        engine_interface.setStream("input_cpu", CPUTypes.FLOAT, N * CPUTypes.FLOAT.sizeInBytes() * din);
		engine_interface.setScalar(s_kernelName, "cellWidth", cellWidth);
		
		// set scalar input for all hash function parameters
		for(int i=0; i<dout; i++){
			for(int j=0; j<din-1; j++){
				String name = String.format("hashFunction%04d", i*(din-1)+j);
				InterfaceParam hash = engine_interface.addParam(name, CPUTypes.FLOAT);
				engine_interface.setScalar(s_kernelName, name, hash);
			}
		}

		// set scalar input for all center point parameters
		for(int i=0; i<dout; i++){
			for(int j=0; j<redundant; j++){
				String name = String.format("centerPoint%04d", i*redundant+j);
				InterfaceParam point = engine_interface.addParam(name, CPUTypes.FLOAT);
				engine_interface.setScalar(s_kernelName, name, point);
			}
		}

		String toCPUPrefix = "output_cpu";
		for(int i=0; i<redundant; i++){
			String toCPU = toCPUPrefix + Integer.toString(i);
			// for every redundant, for every input point, we output two int64_t
			// but in kernel, it is represented as 8 int16_t
			engine_interface.setStream(toCPU, CPUTypes.INT64, N * CPUTypes.INT64.sizeInBytes() * 2);
		}
		
        return engine_interface;
    }

    public static void main(String[] args) {
        LSHManager manager = new LSHManager(new LSHParameters(args));
        manager.build();
    }
}

