/**
 * Document: MaxCompiler Tutorial (maxcompiler-tutorial.pdf)
 * Chapter: 9      Example: 1      Name: Simple Counter
 * MaxFile name: SimpleCounter
 * Summary:
 *       Kernel that shows how to create a simple counter and add
 *   its count to the input stream.
 */

package simplecounter;

import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

class SimpleCounterKernel extends Kernel {

	SimpleCounterKernel(KernelParameters parameters, int width) {
		super(parameters);

		// Input
		DFEVar x = io.input("x", dfeUInt(32));

		// Create a simple counter and add its count to the input
		DFEVar count = control.count.simpleCounter(width);

		DFEVar result = x + count;

		// Output
		io.output("y", result, dfeUInt(width));
	}
	
	private DFEVar judgeDistance(DFEVar x, DFEVar y, DFEVar centerX, DFEVar centerY, DFEVar sqrEps) {
		// return if the distance between center and a certain point is less than sqrEps
		DFEVar diffx = centerX - x;
		DFEVar diffy = centerY - y;
		DFEVar sqrDist = diffx * diffx + diffy * diffy;
		return sqrDist <= sqrEps;
	}
	
	private DFEVar adderTree(DFEVar[] input){
		// the input variable should be float or int
		DFEVar[] sums = new DFEVar[input.length / 2 + (input.length % 2)];
		for (int i = 0; i < input.length / 2; i++) {
			sums[i] = input[2 * i] + input[2 * i + 1];
		}
		if (input.length % 2 == 1) {
			sums[sums.length - 1] = input[input.length - 1];
		}
		return sums.length == 1 ? sums[0] : adderTree(sums);
	}
	
	private DFEVar orTree(DFEVar[] input){
		// the input variable should be dfeBool
		DFEVar[] or = new DFEVar[input.length / 2 + (input.length % 2)];
		for (int i=0; i<input.length / 2; i++) {
			or[i] = input[2 * i] | input[2 * i + 1];
		}
		if (input.length % 2 == 1) {
			or[or.length - 1] = input[input.length - 1];
		}
		return or.length == 1 ? or[0] : orTree(or);
	}

	private DFEVar minTree(DFEVar[] input){
		// the input variable should be float or int
		DFEVar[] minimum = new DFEVar[input.length / 2 + (input.length % 2)];
		for (int i=0; i<input.length / 2; i++) {
			minimum[i] = KernelMath.min(input[2 * i], input[2 * i + 1]);
		}
		if (input.length % 2 == 1) {
			minimum[minimum.length - 1] = input[input.length - 1];
		}
		return minimum.length == 1 ? minimum[0] : minTree(minimum);
	}

	private DFEVar safeOffset(DFEVar input, DFEVar cycle, int offset) {
		// add pipelineFactor to remove the 1 cycle postpone by the buffer
		optimization.pushPipelineFactor(0);
		DFEVar ret_val = cycle < -offset ? 0 : stream.offset(input, offset);
		optimization.popPipilineFactor();
		return ret_val;
	}

}

